<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Jets.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Jets.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Jets</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChevronETC/Jets.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Jop, AbstractArray}" href="#Base.:*-Tuple{Jop, AbstractArray}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">:*(F, m)</code></pre><p>Constructs <code>F*m</code> where F is a Jets linear (e.g. <code>JopLn</code>) or nonlinear (<code>JopNl</code>) operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L384-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{Union{JopAdjoint, JopLn}, Union{JopAdjoint, JopLn}}" href="#Base.:+-Tuple{Union{JopAdjoint, JopLn}, Union{JopAdjoint, JopLn}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">:+(A₂, A₁)</code></pre><p>Construct and return the linear combination of the two <code>Jets</code> operators <code>A₁::Jop</code> and <code>A₂::Jop</code>. Note that <code>A₁</code> and <code>A₂</code> must have consistent (same size and type) domains and ranges.</p><p><strong>Example</strong></p><pre><code class="language-none">A = 1.0*A₁ - 2.0*A₂ + 3.0*A₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L668-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{Union{JopAdjoint, JopLn}, Union{JopAdjoint, JopLn}}" href="#Base.:--Tuple{Union{JopAdjoint, JopLn}, Union{JopAdjoint, JopLn}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">:-(A₂, A₁)</code></pre><p>Construct and return the linear combination of the two <code>Jets</code> operators <code>A₁::Jop</code> and <code>A₂::Jop</code>. Note that <code>A₁</code> and <code>A₂</code> must have consistent (same size and type) domains and ranges.</p><p><strong>Example</strong></p><pre><code class="language-none">A = 1.0*A₁ - 2.0*A₂ + 3.0*A₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L684-L694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∘-Tuple{Union{JopAdjoint, JopLn}, Union{JopAdjoint, JopLn}}" href="#Base.:∘-Tuple{Union{JopAdjoint, JopLn}, Union{JopAdjoint, JopLn}}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">:∘(A₂, A₁)</code></pre><p>Construct the composition of the two <code>Jets</code> operators.  Note that when applying the composition operator, operators are applied in order from right to left: first <code>A₁</code> and then <code>A₂</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Jets
dg!(d,m;mₒ) = @. d = 2*m
A₁ = JopLn(Jet(;dom=JetSpace(Float64,2), rng=JetSpace(Float64,2), df! = dg!))
A₂ = JopLn(Jet(;dom=JetSpace(Float64,2), rng=JetSpace(Float64,2), df! = dg!))
C = A₂ ∘ A₁
m = rand(domain(C))
d = C * m</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L542-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.adjoint-Tuple{JopLn}" href="#Base.adjoint-Tuple{JopLn}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adjoint(A::Union{JopLn, JopAdjoint})</code></pre><p>Return the adjoint of A.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L367-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{T}, Tuple{Type{T}, Jop}} where T&lt;:Array" href="#Base.convert-Union{Tuple{T}, Tuple{Type{T}, Jop}} where T&lt;:Array"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(Array, A::JopLn)</code></pre><p>Convert a linear Jets operator into its equivalent matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L1159-L1163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Tuple{Jet}" href="#Base.eltype-Tuple{Jet}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eltype(A::Union{Jet,Jop,JopAdjoint})</code></pre><p>Return the element type of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L241-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Union{Tuple{JetAbstractSpace{T}}, Tuple{T}} where T" href="#Base.eltype-Union{Tuple{JetAbstractSpace{T}}, Tuple{T}} where T"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eltype(R)</code></pre><p>Return the element type of the space <code>R::JetAbstractSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iszero-Union{Tuple{Jet{D, R, typeof(Jets.JopZeroBlock_df!)}}, Tuple{R}, Tuple{D}} where {D&lt;:JetAbstractSpace, R&lt;:JetAbstractSpace}" href="#Base.iszero-Union{Tuple{Jet{D, R, typeof(Jets.JopZeroBlock_df!)}}, Tuple{R}, Tuple{D}} where {D&lt;:JetAbstractSpace, R&lt;:JetAbstractSpace}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">iszero(A::Union{Jet, Jop})</code></pre><p>Return true if <code>A</code> was constructed via <code>JopZeroBlock</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L934-L938">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{JetAbstractSpace}" href="#Base.length-Tuple{JetAbstractSpace}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(R)</code></pre><p>Return the dimension the space <code>R::JetAbstractSpace</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ones" href="#Base.ones"><code>Base.ones</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ones(R)</code></pre><p>Construct an array of the type and size defined by <code>R::JetAbstractSpace{T}</code> and filled with <code>one(T)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rand(R)</code></pre><p>Construct an array of the type and size defined by the <code>R::JetAbstractSpace</code>, and filled with random values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.range-Tuple{Jet}" href="#Base.range-Tuple{Jet}"><code>Base.range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = range(A)</code></pre><p>Return <code>R::JetAbstractSpace</code>, which is the range of <code>A::Union{Jet, Jop, AbstractMatrix}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L234-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reshape-Tuple{AbstractArray, JetAbstractSpace}" href="#Base.reshape-Tuple{AbstractArray, JetAbstractSpace}"><code>Base.reshape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reshape(x, R)</code></pre><p>Returns an array that is consistent with the shape of the space <code>R::JetAbstractSpace</code>, and shares memory with <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{JetAbstractSpace, Any}" href="#Base.size-Tuple{JetAbstractSpace, Any}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(R[,i])</code></pre><p>Return the shape of the array associated to the Jet space R::JetAbstractSpace. If <code>i</code> is specifid, then returns the length along the ith array dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{Union{Jet, Jop}, Any}" href="#Base.size-Tuple{Union{Jet, Jop}, Any}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(A[, i])</code></pre><p>Return the size of the range and domain of <code>A::Union{Jet,Jop}</code>.  With no arguments, return <code>(length(range(A)), length(domain(A)))</code>.  With <code>i</code> specified, return <code>length(range(A))</code> for <code>i = 1</code> and return <code>length(domain(A))</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L337-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vec-Tuple{Jop}" href="#Base.vec-Tuple{Jop}"><code>Base.vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">B = vec(A)</code></pre><p>B is equivelent to A except that its domain and range are &quot;vectorized&quot;.  This is useful when calling algorithms that expect vectors in the domain and range of the operator.  One example of this is the <code>lsqr</code> method in the IterativeSolvers package.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Jets, JetPack, IterativeSolvers

A = JopDiagonal(rand(10,11))
d = rand(range(A))
m = lsqr(vec(A), vec(d))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L1128-L1143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros" href="#Base.zeros"><code>Base.zeros</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">zeros(R)</code></pre><p>Construct an array of the type and size defined by <code>R::JetAbstractSpace{T}</code> and filled with <code>zero(T)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.JopZeroBlock-Tuple{JetAbstractSpace, JetAbstractSpace}" href="#Jets.JopZeroBlock-Tuple{JetAbstractSpace, JetAbstractSpace}"><code>Jets.JopZeroBlock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopZeroBlock(dom, rng)</code></pre><p>Construct a Jets operator that is equivalent to a matrix of zeros, and that maps from <code>dom::JetAbstractSpace</code> to <code>rng::JetAbstractSpace</code>.  This can be useful when forming block operators that contain zero blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L925-L930">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.domain-Tuple{Jet}" href="#Jets.domain-Tuple{Jet}"><code>Jets.domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = domain(A)</code></pre><p>Return <code>R::JetAbstractSpace</code>, which is the domain of <code>A::Union{Jet, Jop, AbstractMatrix}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.dot_product_test-Tuple{JopLn, AbstractArray, AbstractArray}" href="#Jets.dot_product_test-Tuple{JopLn, AbstractArray, AbstractArray}"><code>Jets.dot_product_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lhs,rhs = dot_product_test(A, m, d; mmask, dmask)</code></pre><p>Compute and return the left and right hand sides of the <em>dot product test</em>:</p><p><code>&lt;d,Am&gt; ≈ &lt;Aᴴd,m&gt;</code></p><p>Here <code>Aᴴ</code> is the conjugate transpose or adjoint of <code>A</code>, and <code>&lt;x, y&gt;</code> denotes the inner product of vectors <code>x</code> and <code>y</code>. The left and right hand sides of the dot product test are expected to be equivalent close to machine precision for operator <code>A</code>. If the equality does not hold this can indicate a problem with the implementation of the operator <code>A</code>.</p><p>This function provides the optional named arguments <code>mmask</code> and <code>dmask</code> which are vectors in the domain and range of <code>A</code> that are applied via elementwise multiplication to mask the vectors <code>m</code> and <code>d</code> before applying of the operator, as shown below. Here we use <code>∘</code> to represent the Hadamard product (elementwise multiplication) of two vectors.</p><p><code>&lt;dmask ∘ d, A (mmask ∘ m)&gt; ≈ &lt;Aᵀ (dmask ∘ d), mmask ∘ m&gt;</code></p><p>You can test the relative accuracy of the operator with this relation for the left hand side <code>lhs</code> and right hand side <code>rhs</code> returned by this function: </p><p><code>|lhs - rhs| / |lhs + rhs| &lt; ϵ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L1177-L1200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.getblock-Union{Tuple{R}, Tuple{D}, Tuple{Jet{D, R, typeof(Jets.JetBlock_f!)}, Any, Any}} where {D, R}" href="#Jets.getblock-Union{Tuple{R}, Tuple{D}, Tuple{Jet{D, R, typeof(Jets.JetBlock_f!)}, Any, Any}} where {D, R}"><code>Jets.getblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getblock(A, i, j)</code></pre><p>Return the block of the Jets block operator <code>A</code> that corresponds to row block <code>i</code> and column block <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L1069-L1074">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.indices-Tuple{JetBSpace, Integer}" href="#Jets.indices-Tuple{JetBSpace, Integer}"><code>Jets.indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">indices(R, iblock)</code></pre><p>Return the linear indices associated with block <code>iblock</code> in the <code>Jets</code> block space <code>R::JetBSpace</code>.</p><p><strong>Example</strong></p><p>Consider a block operator with 2 row-blocks and 3 column-blocks.  We can use <code>indices</code> to determine the elements of the vector that are associatd with the first block of its domain:</p><pre><code class="language-none">using Pkg
pkg&quot;add Jets JetPack&quot;
using Jets, JetPack
A = @blockop [JopDiagonal(rand(10)) for irow=1:2, icol=1:3]
indices(domain(A), 1) # returns indices 1:10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L752-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.isblockop-Tuple{Jop{&lt;:Jet{&lt;:JetAbstractSpace, &lt;:JetAbstractSpace, typeof(Jets.JetBlock_f!)}}}" href="#Jets.isblockop-Tuple{Jop{&lt;:Jet{&lt;:JetAbstractSpace, &lt;:JetAbstractSpace, typeof(Jets.JetBlock_f!)}}}"><code>Jets.isblockop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isblockop(A)</code></pre><p>Return true if <code>A</code> is a Jets block operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L1082-L1086">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.jacobian!-Tuple{Jet, AbstractArray}" href="#Jets.jacobian!-Tuple{Jet, AbstractArray}"><code>Jets.jacobian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jacobian!(F, mₒ)</code></pre><p>Return the jacobian of <code>F::Union{Jet, Jop, AbstractMatrix}</code> at the linearization point <code>m₀</code>. The jacobian shares the underlying <code>Jet</code> with <code>F</code>. This means that if the jacobian may mutate <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L347-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.jacobian-Tuple{Union{Jet, Jop}, AbstractArray}" href="#Jets.jacobian-Tuple{Union{Jet, Jop}, AbstractArray}"><code>Jets.jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jacobian(F, mₒ)</code></pre><p>Return the jacobian of <code>F::Union{Jet, Jop, AbstractMatrix}</code> at the point <code>m₀</code>. The linearization constructs a new underlying <code>Jet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L358-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.jet-Tuple{Jop}" href="#Jets.jet-Tuple{Jop}"><code>Jets.jet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jet(A)</code></pre><p>Return the <code>Jet</code> associated with <code>A::Union{Jop, JopAdjoint}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L293-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.linearity_test" href="#Jets.linearity_test"><code>Jets.linearity_test</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lhs,rhs = linearity_test(A::Jop)</code></pre><p>test the the linear Jet operator <code>A</code> satisfies the following test for linearity: </p><p><code>A(m_1+m_2)=Am_1 + A_m2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L1258-L1265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.linearization_test-Tuple{JopNl, AbstractArray}" href="#Jets.linearization_test-Tuple{JopNl, AbstractArray}"><code>Jets.linearization_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">μobs, μexp = linearization_test(F, mₒ; μ)</code></pre><p>Thest that the jacobian, <code>J</code>, of <code>F</code> satisfies the Taylor expansion:</p><p><code>F(m) = F(m_o) + F&#39;(m_o)δm + O(δm^2)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L1218-L1224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.nblocks-Tuple{JetBSpace}" href="#Jets.nblocks-Tuple{JetBSpace}"><code>Jets.nblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nblocks(R)</code></pre><p>Return the number of blocks in the <code>Jets</code> block space <code>R::JetBSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L791-L795">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.nblocks-Tuple{Jet}" href="#Jets.nblocks-Tuple{Jet}"><code>Jets.nblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nblocks(A[, i])</code></pre><p>Return the number of blocks in the range and domain of the <code>Jets</code> block operator <code>A::Union{Jet, Jop}</code>. With <code>i</code> specified, return <code>nblocks(range(jet))</code> for <code>i = 1</code> and return <code>nblocks(domain(jet))</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L1058-L1063">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.perfstat-Union{Tuple{T}, Tuple{F}, Tuple{R}, Tuple{D}} where {D, R, F&lt;:Function, T&lt;:(Jet{D, R, F})}" href="#Jets.perfstat-Union{Tuple{T}, Tuple{F}, Tuple{R}, Tuple{D}} where {D, R, F&lt;:Function, T&lt;:(Jet{D, R, F})}"><code>Jets.perfstat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perfstat(A)</code></pre><p>Return a <code>Dictionary</code> with performance information for A::Union{Jet,Jop,JopAdjoint}. the <code>perfstat(jet::Jet)</code> method that can be implemented by the author of an operator to track performance metrics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L264-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.point!-Tuple{Jet, AbstractArray}" href="#Jets.point!-Tuple{Jet, AbstractArray}"><code>Jets.point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">point!(F, mₒ)</code></pre><p>Update the linearization point (model vector) for <code>F::Union{Jet, JopLn, JopAdjoint}</code> to model vector <code>mₒ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L282-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.point-Tuple{Jet}" href="#Jets.point-Tuple{Jet}"><code>Jets.point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">point(F)</code></pre><p>Return the linearization point (model vector) <code>mₒ</code> associated with <code>F::Union{Jet, JopLn, JopAdjoint}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L273-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.shape-Tuple{Union{Jet, Jop}}" href="#Jets.shape-Tuple{Union{Jet, Jop}}"><code>Jets.shape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shape(A[, i])</code></pre><p>Return the shape of the range and domain of <code>A::Union{Jet, Jop, AbstractMatrix}</code>. With no arguments, return <code>(size(range(A)), size(domain(A)))</code>.  With <code>i</code> specified, return <code>size(range(A))</code> for <code>i = 1</code> and return <code>size(domain(A))</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L325-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.space-Tuple{JetBSpace, Integer}" href="#Jets.space-Tuple{JetBSpace, Integer}"><code>Jets.space</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">space(R, iblock)</code></pre><p>Return the <code>Jets</code> sub-space associated with block <code>iblock</code> in the <code>Jets</code> block space <code>R::JetBSpace</code>.</p><p><strong>Example</strong></p><p>Consider a block operator with 2 row-blocks and 3 column-blocks.  We can use <code>space</code> to determine the sub-space associated with the first block of its domain:</p><pre><code class="language-none">using Pkg
pkg&quot;add Jets JetPack&quot;
using Jets, JetPack
A = @blockop [JopDiagonal(rand(10)) for irow=1:2, icol=1:3]
space(domain(A), 1) # JetSpace(Float64,10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L772-L788">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.state!-Tuple{Any, Any}" href="#Jets.state!-Tuple{Any, Any}"><code>Jets.state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">state!(A::Union{Jet,Jop,JopAdjoint}, s)</code></pre><p>Updates and merges the state of the <code>A</code> with <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L257-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.state-Tuple{Jet}" href="#Jets.state-Tuple{Jet}"><code>Jets.state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">state(A::Union{Jet,Jop,JopAdjoint}[, key])</code></pre><p>If <code>key::Symbol</code> is specified, then return the state corresponding to <code>key</code>. Otherwise, return the state of A as a <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L248-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{AbstractArray, JopNl, AbstractArray}" href="#LinearAlgebra.mul!-Tuple{AbstractArray, JopNl, AbstractArray}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mul!(d, F, m)</code></pre><p>In place version of <code>d=F*m</code> where F is a Jets linear (e.g. <code>JopLn</code>) or nonlinear (<code>JopNl</code>) operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L375-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.randperm-Tuple{JetAbstractSpace, Int64}" href="#Random.randperm-Tuple{JetAbstractSpace, Int64}"><code>Random.randperm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randperm(R)</code></pre><p>Construct a list of random linear indices over the dimensions of <code>R::JetAbstractSpace</code>.  The list is useful for selecting a random subset of a multi-dimensional image.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Jets
R = JetSpace(Float64, 10, 2)
x = rand(R)
y = x[randperm(R)[1:10]] # get 10 elements at random from x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L103-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Array" href="#Core.Array"><code>Core.Array</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Array(R)</code></pre><p>Construct an uninitialized array of the type and size defined by <code>R::JetsAbstractSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.Jet-Tuple{}" href="#Jets.Jet-Tuple{}"><code>Jets.Jet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jet(;dom, rng, f!, df!, df′!, upstate!, s)</code></pre><p>Return a <code>Jet</code> with domain <code>dom::JetAbstractSpace</code>, range <code>rng::JetSAbstractpace</code>, with forward mapping  <code>f!::Function</code>, linearized forward mapping <code>df!::Function</code>, linearized adjoint mapping <code>df′!::Function</code>, Jacobian state modification function <code>upstate!::Function</code>, and state <code>s::NamedTuple</code>.</p><p>A jet describes a function <code>f!</code> and its linearization (forward <code>df!, and adjoint</code>df′!``) about a point.</p><p>If one of <code>f!</code> or <code>df!</code> is specified, and <code>df′!</code> is not, then we assume that <code>f!=df!=df′!</code>. This means that the operator is linear and self-adjoint.</p><p>If <code>f!</code> and <code>df!</code> are sepecified, bug <code>df′!</code> is not, then we assume that <code>df′!=df!</code>.  This means that the operator is nonlinear and self-adjoint.</p><p><strong>Example</strong></p><p>Consider a nonlinear mapping with a self-adjoint linearization <span>$f(x)=x^2$</span></p><pre><code class="language-julia">using Jets
g!(m) = m.^2
dg!(δm; mₒ) = @. 2*mₒ*δm
jet = Jet(;dom=JetSpace(Float64,2), rng=JetSpace(Float64,2), f! = g!, df! = dg!)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L134-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.JetSSpace-Union{Tuple{F}, Tuple{N}, Tuple{T}, Tuple{Type{T}, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}, F}} where {T, N, F}" href="#Jets.JetSSpace-Union{Tuple{F}, Tuple{N}, Tuple{T}, Tuple{Type{T}, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}, F}} where {T, N, F}"><code>Jets.JetSSpace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JetSSpace(_T, n, M, map::F)</code></pre><p>Construct and return a symmetric space <code>JetSSpace</code>.</p><p><strong>parameters</strong></p><ul><li><code>_T</code> is the type, usually <code>Complex{Float32}</code> or <code>Complex{Float64}</code>.</li><li><code>n</code> is a tuple that defines the dimensionality of the space.</li><li><code>M</code> is a tuple that defines which dimensions are symmetric. Note that currently only a single symmetric dimension is supported by the API.</li><li><code>F</code> is a function that maps indices for the symmetric dimension, described below.</li></ul><p>An example requiring a <code>JetSSpace</code> is the Fourier transform: the Fourier transform of a real vector is in a complex space with Hermittian symmetry. Only the positive frequencies are needed, and the spectrum at negative frequencies is the Hermittian conjugate of the spectrum at the corresponding positive frequencies: <code>S(-f) = conj(S(f)</code>. For this example the map <code>F</code> is a function that returns the multi-dimensional index of <code>f</code> when given the multi-dimensional index of <code>-f</code>.</p><p>See also: <code>JopFft</code> in the <code>JetPackTransforms</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L404-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.JetSpace-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Vararg{Int64, N}}} where {T, N}" href="#Jets.JetSpace-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Vararg{Int64, N}}} where {T, N}"><code>Jets.JetSpace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JetSpace(T, n)</code></pre><p>Construct and return a JetSpace of type <code>T</code> and size <code>n</code></p><p><strong>Examples</strong></p><p>Create a 100 dimension space with array elelment type Float64 and array size (100,)</p><pre><code class="language-none">R1 = JetSpace(Float64, 100)</code></pre><p>Create a 100 dimension space with array element type Float32 and array size (5, 20)</p><pre><code class="language-none">R2 = JetSpace(Float32, 5, 20)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L44-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.JopLn-Tuple{}" href="#Jets.JopLn-Tuple{}"><code>Jets.JopLn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopLn(; kwargs ...)</code></pre><p>Construct a <code>JopLn</code> with <code>Jet</code> constructed from keyword arguments <code>kwargs</code>. This is equivalent to <code>JopLn(Jet(;kwargs...))</code>.  Please see <code>Jet</code> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L204-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.JopNl-Tuple{}" href="#Jets.JopNl-Tuple{}"><code>Jets.JopNl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNl(; kwargs ...)</code></pre><p>Construct a <code>JopNl</code> with <code>Jet</code> constructed from keyword arguments <code>kwargs</code>. This is equivalent to <code>JopNl(Jet(;kwargs...))</code>.  Please see <code>Jet</code> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/15360deaac3e7984fc82ceff392ade47e73a5797/src/Jets.jl#L190-L196">source</a></section></article><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#Core.Array"><code>Core.Array</code></a></li><li><a href="#Jets.Jet-Tuple{}"><code>Jets.Jet</code></a></li><li><a href="#Jets.JetSSpace-Union{Tuple{F}, Tuple{N}, Tuple{T}, Tuple{Type{T}, Tuple{Vararg{Int64, N}}, Tuple{Vararg{Int64, N}}, F}} where {T, N, F}"><code>Jets.JetSSpace</code></a></li><li><a href="#Jets.JetSpace-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Vararg{Int64, N}}} where {T, N}"><code>Jets.JetSpace</code></a></li><li><a href="#Jets.JopLn-Tuple{}"><code>Jets.JopLn</code></a></li><li><a href="#Jets.JopNl-Tuple{}"><code>Jets.JopNl</code></a></li><li><a href="#Base.:*-Tuple{Jop, AbstractArray}"><code>Base.:*</code></a></li><li><a href="#Base.:+-Tuple{Union{JopAdjoint, JopLn}, Union{JopAdjoint, JopLn}}"><code>Base.:+</code></a></li><li><a href="#Base.:--Tuple{Union{JopAdjoint, JopLn}, Union{JopAdjoint, JopLn}}"><code>Base.:-</code></a></li><li><a href="#Base.:∘-Tuple{Union{JopAdjoint, JopLn}, Union{JopAdjoint, JopLn}}"><code>Base.:∘</code></a></li><li><a href="#Base.adjoint-Tuple{JopLn}"><code>Base.adjoint</code></a></li><li><a href="#Base.convert-Union{Tuple{T}, Tuple{Type{T}, Jop}} where T&lt;:Array"><code>Base.convert</code></a></li><li><a href="#Base.eltype-Tuple{Jet}"><code>Base.eltype</code></a></li><li><a href="#Base.eltype-Union{Tuple{JetAbstractSpace{T}}, Tuple{T}} where T"><code>Base.eltype</code></a></li><li><a href="#Base.iszero-Union{Tuple{Jet{D, R, typeof(Jets.JopZeroBlock_df!)}}, Tuple{R}, Tuple{D}} where {D&lt;:JetAbstractSpace, R&lt;:JetAbstractSpace}"><code>Base.iszero</code></a></li><li><a href="#Base.length-Tuple{JetAbstractSpace}"><code>Base.length</code></a></li><li><a href="#Base.ones"><code>Base.ones</code></a></li><li><a href="#Base.rand"><code>Base.rand</code></a></li><li><a href="#Base.range-Tuple{Jet}"><code>Base.range</code></a></li><li><a href="#Base.reshape-Tuple{AbstractArray, JetAbstractSpace}"><code>Base.reshape</code></a></li><li><a href="#Base.size-Tuple{Union{Jet, Jop}, Any}"><code>Base.size</code></a></li><li><a href="#Base.size-Tuple{JetAbstractSpace, Any}"><code>Base.size</code></a></li><li><a href="#Base.vec-Tuple{Jop}"><code>Base.vec</code></a></li><li><a href="#Base.zeros"><code>Base.zeros</code></a></li><li><a href="#Jets.JopZeroBlock-Tuple{JetAbstractSpace, JetAbstractSpace}"><code>Jets.JopZeroBlock</code></a></li><li><a href="#Jets.domain-Tuple{Jet}"><code>Jets.domain</code></a></li><li><a href="#Jets.dot_product_test-Tuple{JopLn, AbstractArray, AbstractArray}"><code>Jets.dot_product_test</code></a></li><li><a href="#Jets.getblock-Union{Tuple{R}, Tuple{D}, Tuple{Jet{D, R, typeof(Jets.JetBlock_f!)}, Any, Any}} where {D, R}"><code>Jets.getblock</code></a></li><li><a href="#Jets.indices-Tuple{JetBSpace, Integer}"><code>Jets.indices</code></a></li><li><a href="#Jets.isblockop-Tuple{Jop{&lt;:Jet{&lt;:JetAbstractSpace, &lt;:JetAbstractSpace, typeof(Jets.JetBlock_f!)}}}"><code>Jets.isblockop</code></a></li><li><a href="#Jets.jacobian-Tuple{Union{Jet, Jop}, AbstractArray}"><code>Jets.jacobian</code></a></li><li><a href="#Jets.jacobian!-Tuple{Jet, AbstractArray}"><code>Jets.jacobian!</code></a></li><li><a href="#Jets.jet-Tuple{Jop}"><code>Jets.jet</code></a></li><li><a href="#Jets.linearity_test"><code>Jets.linearity_test</code></a></li><li><a href="#Jets.linearization_test-Tuple{JopNl, AbstractArray}"><code>Jets.linearization_test</code></a></li><li><a href="#Jets.nblocks-Tuple{Jet}"><code>Jets.nblocks</code></a></li><li><a href="#Jets.nblocks-Tuple{JetBSpace}"><code>Jets.nblocks</code></a></li><li><a href="#Jets.perfstat-Union{Tuple{T}, Tuple{F}, Tuple{R}, Tuple{D}} where {D, R, F&lt;:Function, T&lt;:(Jet{D, R, F})}"><code>Jets.perfstat</code></a></li><li><a href="#Jets.point-Tuple{Jet}"><code>Jets.point</code></a></li><li><a href="#Jets.point!-Tuple{Jet, AbstractArray}"><code>Jets.point!</code></a></li><li><a href="#Jets.shape-Tuple{Union{Jet, Jop}}"><code>Jets.shape</code></a></li><li><a href="#Jets.space-Tuple{JetBSpace, Integer}"><code>Jets.space</code></a></li><li><a href="#Jets.state-Tuple{Jet}"><code>Jets.state</code></a></li><li><a href="#Jets.state!-Tuple{Any, Any}"><code>Jets.state!</code></a></li><li><a href="#LinearAlgebra.mul!-Tuple{AbstractArray, JopNl, AbstractArray}"><code>LinearAlgebra.mul!</code></a></li><li><a href="#Random.randperm-Tuple{JetAbstractSpace, Int64}"><code>Random.randperm</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Jets</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 14 September 2022 20:58">Wednesday 14 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

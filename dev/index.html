<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Jets · Jets.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Jets.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Jets</a><ul class="internal"><li><a class="tocitem" href="#Companion-packages-in-the-COFII-framework"><span>Companion packages in the COFII framework</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Vector-spaces"><span>Vector spaces</span></a></li><li><a class="tocitem" href="#Jets-2"><span>Jets</span></a></li><li><a class="tocitem" href="#Linear-and-nonlinear-operators"><span>Linear and nonlinear operators</span></a></li><li><a class="tocitem" href="#Operator-compositions"><span>Operator compositions</span></a></li><li><a class="tocitem" href="#Operator-linear-combinations"><span>Operator linear combinations</span></a></li><li><a class="tocitem" href="#Block-operators,-block-spaces-and-block-vectors"><span>Block operators, block spaces and block vectors</span></a></li><li><a class="tocitem" href="#Vectorized-operators"><span>Vectorized operators</span></a></li><li><a class="tocitem" href="#Creating-a-new-Jet-(Developers)"><span>Creating a new Jet (Developers)</span></a></li></ul></li><li><a class="tocitem" href="reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Jets</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Jets</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChevronETC/Jets.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Jets"><a class="docs-heading-anchor" href="#Jets">Jets</a><a id="Jets-1"></a><a class="docs-heading-anchor-permalink" href="#Jets" title="Permalink"></a></h1><p>Jets is a Julia library for matrix-free linear algebra and nonlinear optimization.</p><p>Other Julia packages that provide similar functionality include:</p><ul><li>LinearMaps - <a href="https://github.com/Jutho/LinearMaps.jl">https://github.com/Jutho/LinearMaps.jl</a></li><li>FunctionalOperators - <a href="https://github.com/hakkelt/FunctionOperators.jl">https://github.com/hakkelt/FunctionOperators.jl</a></li><li>AbstractOperators - <a href="https://github.com/kul-forbes/AbstractOperators.jl">https://github.com/kul-forbes/AbstractOperators.jl</a></li><li>JOLI - <a href="https://github.com/slimgroup/JOLI.jl">https://github.com/slimgroup/JOLI.jl</a></li><li>BlockArrays - <a href="https://github.com/JuliaArrays/BlockArrays.jl">https://github.com/JuliaArrays/BlockArrays.jl</a> </li></ul><p>The purpose of Jets is to provide familiar matrix-vector syntax without forming matrices. Instead, the action of the matrix and its adjoint applied to vectors is specified using Julia methods. In addition, Jets provides a framework for nonlinear functions and their linearization. The main construct in this package is a <code>jet</code> and is loosely based on its mathematical namesake (<a href="https://en.wikipedia.org/wiki/Jet_(mathematics)">https://en.wikipedia.org/wiki/Jet_(mathematics)</a>). In particular,  a <code>jet</code> describes a function and its linearization at some point in its domain.</p><h2 id="Companion-packages-in-the-COFII-framework"><a class="docs-heading-anchor" href="#Companion-packages-in-the-COFII-framework">Companion packages in the COFII framework</a><a id="Companion-packages-in-the-COFII-framework-1"></a><a class="docs-heading-anchor-permalink" href="#Companion-packages-in-the-COFII-framework" title="Permalink"></a></h2><ul><li>DistributedJets - <a href="https://github.com/ChevronETC/DistributedJets.jl">https://github.com/ChevronETC/DistributedJets.jl</a></li><li>JetPack - <a href="https://github.com/ChevronETC/JetPack.jl">https://github.com/ChevronETC/JetPack.jl</a></li><li>JetPackDSP - <a href="https://github.com/ChevronETC/JetPackDSP.jl">https://github.com/ChevronETC/JetPackDSP.jl</a></li><li>JetPackWaveFD - <a href="https://github.com/ChevronETC/JetPackWaveFD.jl">https://github.com/ChevronETC/JetPackWaveFD.jl</a></li><li>JetPackTransforms - <a href="https://github.com/ChevronETC/JetPackTransforms.jl">https://github.com/ChevronETC/JetPackTransforms.jl</a></li></ul><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>Jets as well as its companion packages can be installed via the Julia built-in package manager <code>Pkg</code>:</p><pre><code class="language-julia">using Pkg
Pkg.add([&quot;Jets&quot;, &quot;JetPack&quot;, &quot;JetPackDSP&quot;, 
    &quot;JetPackWaveFD&quot;, &quot;JetPackTransforms&quot;, &quot;DistributedJets&quot;])</code></pre><p>In addition, the packages <code>LinearAlgebra</code> and <code>IterativeSolvers</code> are also used in this document. Installation can be conducted in the same fashion if not yet done so.</p><h2 id="Vector-spaces"><a class="docs-heading-anchor" href="#Vector-spaces">Vector spaces</a><a id="Vector-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-spaces" title="Permalink"></a></h2><p>The domain and range of a jet are vector spaces. In <code>Jets</code>, a vector space is represented by one of three concrete types:</p><pre><code class="language-julia">JetSpace &lt;: JetAbstractSpace
JetSSpace &lt;: JetAbstractSpace
JetBSpace &lt;: JetAbstractSpace</code></pre><h3 id="JetSpace"><a class="docs-heading-anchor" href="#JetSpace">JetSpace</a><a id="JetSpace-1"></a><a class="docs-heading-anchor-permalink" href="#JetSpace" title="Permalink"></a></h3><p><code>JetSpace</code> is an n-dimensional vector space with additional meta-data. The addition meta-data is:</p><ul><li>a <strong>size</strong> <code>(n₁,n₂,...,nₚ)</code> where <code>prod(n₁,n₂,...,nₚ)=n</code></li><li>a <strong>type</strong> such as <code>Float32</code>, <code>Complex{Float64}</code>, etc.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using Jets                           # load the Jets package
R₁ = JetSpace(Float32, 10)           # 10 dimensional space using single precision floats
R₂ = JetSpace(Float64, 10, 20)       # 200 dimensional space with array size 10×20 using double precision floats
R₃ = JetSpace(ComplexF32, 10, 20, 2) # 400 dimensional space with array size 10×20×2 using single precision floats</code></pre><p>The choice of <strong>shape</strong> and <strong>type</strong> will have various consequences. For example, using the <code>rand</code> convenience function to construct vectors within the space will have the following effects:</p><pre><code class="language-julia">x₁ = rand(R₁) # x₁ will be a 1 dimensional array of length 10 and type Float32
x₂ = rand(R₂) # x₂ will be a 2 dimensional array of size (10,20) and type Float64
x₃ = rand(R₃) # x₃ will be a 3 dimensional array of size (10,20,2) and type ComplexF32</code></pre><h3 id="JetSSpace"><a class="docs-heading-anchor" href="#JetSSpace">JetSSpace</a><a id="JetSSpace-1"></a><a class="docs-heading-anchor-permalink" href="#JetSSpace" title="Permalink"></a></h3><p>There are jets that lead to symmetries in their domain/range, and those symmetries can be used for increased computational efficiency. For example, the Fourier transform of a real vector has Hermitian symmetry for negative frequencies. <code>JetSSpace</code> is used to construct an array that includes extra information about these symmetries. In general, jets that have symmetric spaces should provide a method <code>symspace</code> for the construction of its symmetric space. </p><p><strong>Example</strong></p><pre><code class="language-julia">using Jets, JetPackTransforms       # load packages
A = JopFft(JetSpace(Float64, 128))  # define a Jet A that applies Fourier transform to a 128-dimensional Float64 vector
R = range(A)                        # the range of A is a symmetric space R&lt;:JetSSpace (because the domain of A is a real vector)</code></pre><h3 id="JetBSpace"><a class="docs-heading-anchor" href="#JetBSpace">JetBSpace</a><a id="JetBSpace-1"></a><a class="docs-heading-anchor-permalink" href="#JetBSpace" title="Permalink"></a></h3><p><code>Jets</code> provides a block jet that is analogous to a block matrix. The domain and range associated with a block jet is a <code>JetBSpace</code>, and a <code>JetBSpace</code> adds book-keeping information to describe this blocked structure. For more information, please see the block jet documentation, below.</p><h3 id="Convenience-methods-for-Jet-vector-spaces"><a class="docs-heading-anchor" href="#Convenience-methods-for-Jet-vector-spaces">Convenience methods for Jet vector spaces</a><a id="Convenience-methods-for-Jet-vector-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-methods-for-Jet-vector-spaces" title="Permalink"></a></h3><p>Jets provides the following convenience methods for all concrete Jet Vector spaces <code>R::JetAbstractSpace</code>:</p><pre><code class="language-julia">eltype(R)     # element type of R
ndims(R)      # number of dimensions of arrays in `R`
length(R)     # length of arrays in `R` and is equivalent to `prod(size(R))`
size(R)       # size of arrays in `R`
reshape(x, R) # reshape `x::AbstractArray` to the size of `R`
ones(R)       # array of ones with the element-type and size of `R`
rand(R)       # random array with the element-type and size of `R`
zeros(R)      # zero array with the element-type and size of `R`
Array(R)      # uninitialized array with the element-type and size of `R`
vec(R)        # return a similar space, but backed by a one dimensional array</code></pre><h2 id="Jets-2"><a class="docs-heading-anchor" href="#Jets-2">Jets</a><a class="docs-heading-anchor-permalink" href="#Jets-2" title="Permalink"></a></h2><p>A jet <code>jet::Jet</code> is the main construct in this package. It can be used on its own; but is more often wrapped in a linear or nonlinear operator which will be discussed shortly. We associate the following methods with <code>jet::Jet</code>:</p><pre><code class="language-julia">f!(d, jet, m; kwargs...)   # function map from domain to range
df!(d, jet, m; kwargs...)  # linearized function map from domain to range
df′!(m, jet, d; kwargs...) # linearized adjoint function map from range to domain
domain(jet)                # domain of jet
range(jet)                 # range of jet
eltype(jet)                # element-type of the jet
shape(jet)                 # shape of the domain and range of jet
shape(jet, i)              # shape of the range (i=1) or domain (i=2) of jet
size(jet)                  # size of the domain and range of jet
size(jet,i)                # size of the range (i=1) or domain (i=2) of jet
state(jet)                 # named tuple containing state information of jet
state!(jet, s)             # update the state information of jet via the named tuple, s
point(jet)                 # get the point that the linearization is about
point!(jet, mₒ)            # set the point that the linearization is about
close(jet)                 # closing a jet makes an explicit call to its finalizers</code></pre><p>Note that the <code>f!</code>, <code>df!</code>, <code>df′!</code> and <code>point!</code> methods are not exported.</p><p><strong>Example, creating a jet for the function <code>f(x)=x^a</code></strong></p><pre><code class="language-julia">using Jets                                  # load package
foo!(d, m; a, kwargs...) =                  # define the nonlinear function
    d .= m.^a
dfoo!(δd, δm; mₒ, a, kwargs...) =           # define the linearization
    δd .= a * mₒ.^(a-1) .* δm
myjet = Jet(dom = JetSpace(Float64, 5),     # construct the jet
    rng = JetSpace(Float64, 5), f! = foo!, 
    df! = dfoo!, s = (a=2.0,))</code></pre><p>In the above construction, we define the domain (<code>dom</code>), range (<code>rng</code>), and a function (<code>f!</code>) with its linearization (<code>df!</code>). In addition, the jet contains <em>state</em>. In this case the state is the value of the exponent <code>a</code>. The state is passed to the jet using the named tuple <code>s = (a=2.0,)</code>. Notice that construction of the jet uses Julia&#39;s named arguments.</p><p>Additionally, note that <code>mₒ</code> is <code>m</code> with the lower-case letter <code>o</code> for the subscript.</p><p>Finally, we note that for this specific example, the construction does not specify the adjoint of the lineariziation. This is because for this specific case the linearization is self-adjoint. An equivalent construction that explicitly includes the adjoint is:</p><pre><code class="language-julia">myjet = Jet(dom = JetSpace(Float64, 5),
    rng = JetSpace(Float64, 5), f! = foo!, 
    df! = dfoo!, df′! = dfoo!, s = (a=2.0,))</code></pre><p>Note that the <code>′</code> (prime) in the keyword <code>df′!</code> is the unicode character that can be produced by typing <code>\prime</code> followed by <strong>TAB</strong>.</p><h2 id="Linear-and-nonlinear-operators"><a class="docs-heading-anchor" href="#Linear-and-nonlinear-operators">Linear and nonlinear operators</a><a id="Linear-and-nonlinear-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-and-nonlinear-operators" title="Permalink"></a></h2><p>A jet can be wrapped into nonlinear (<code>JopNl</code>) and linear (<code>JopLn</code>) operators. When we wrap a nonlinear operator around a jet, we must also specify the point at which we linearize. The same methods that were applied to a jet can be applied to <code>Jets</code> operators: <code>domain</code>, <code>range</code>, <code>eltype</code>, <code>shape</code>, <code>size</code>, <code>state</code>, <code>state!</code>, <code>close</code>. In addition, given a linear operator, we can recover the corresponding matrix with method <code>convert</code>. Continuing from the <code>myjet</code> defined in the previous section, we first show a nonlinear operator and then its linearization as a linear operator followed by the associated adjoint operator.</p><p><strong>Example: nonlinear operator</strong></p><pre><code class="language-julia">using LinearAlgebra     # load package to enable the function mul!
F = JopNl(myjet)        # wrap myjet into a nonlinear operator F
m = rand(domain(F))     # m is a vector in domain(F)
d₁ = Array(range(F))    # initialize d₁ in the range of F
mul!(d₁, F, m)          # in-place implementation of F via foo! method
d₂ = F * m              # equivalent of the previous line (not in-place)
d₃ = m .^ 2             # ground truth output of the nonlinear function
display([d₁, d₂, d₃])   # compare the F outputs with the ground truth</code></pre><p><strong>Example: linear operator</strong></p><pre><code class="language-julia">mₒ = rand(domain(F))            # specify the point that the linearization is about
δF = JopLn(myjet, mₒ)           # wrap (the lineaerization of) myjet into a linear operator δF
δF₂ = jacobian(F, mₒ)           # equivalently, the same JopLn can be defined with JopNl&#39;s Jacobian
M_δF = convert(Array, δF)       # convert δF into its corresponding array (matrix)
M_δF₂ = convert(Array, δF₂)     # convert δF₂ into its corresponding array (matrix)
display(M_δF)                   # display the diagonal matrix corresponding to δF
display(M_δF₂)                  # demonstrate the equivalence of the two definitions (δF and δF₂)
δm = rand(domain(δF))           # specify δm in the domain of the linear operator δF
δd₁ = Array(range(δF))          # initialize δd₁ in the range of the linear operator δF
mul!(δd₁, δF, δm)               # in-place implementation of F via dfoo! method
δd₂ = δF * δm                   # equivalent of the previous line (not in-place)
δd₃ = 2 .* mₒ .* (2 - 1) .* δm  # ground truth output of the linear operator
display([δd₁, δd₂, δd₃])        # compare the δF outputs with the ground truth</code></pre><p><strong>Example: adjoint operator</strong></p><pre><code class="language-julia">d = rand(range(δF))             # specify d in the range of δF for adjoint computation
a₁ = Array(domain(δF))          # initialize a₁ in the domain of δF (range of its adjoint)
mul!(a₁, δF&#39;, d)                # in-place implementation of F via the self-adjoint dfoo! method
a₂ = δF&#39; * d                    # equivalent of the previous line (not in-place)
a₃ = 2 .* mₒ .* (2 - 1) .* d    # ground truth output of the adjoint linear operator
display([a₁, a₂, a₃])           # compare the δF&#39; outputs with the ground truth</code></pre><p>Note that the <code>&#39;</code> in <code>δF&#39;</code> is the trailing apostrophe, i.e., the adjoint (complex transpose) operator in Julia.</p><h2 id="Operator-compositions"><a class="docs-heading-anchor" href="#Operator-compositions">Operator compositions</a><a id="Operator-compositions-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-compositions" title="Permalink"></a></h2><p>Jet operators can be combined in various ways. In this section we consider operator compositions. Operators are composed using <code>∘</code> which can be typed into your favorite text editor using unicode. Note that editors such as emacs, vim, atom, vscode, and JupyterLab support using LaTeX. So, typing <code>\circ</code> followed by <strong>TAB</strong> will produce <code>∘</code>.</p><p><strong>Example of operator compositions</strong>  </p><pre><code class="language-julia">using Jets, JetPack
A₁ = JopDiagonal(rand(10))
A₂ = JopDiagonal(rand(10))
A₃ = rand(10,10)
A = A₃ ∘ A₂ ∘ A₁                # operator composition
m = rand(domain(A))
A * m ≈ A₃ * (A₂ * (A₁ * m))    # true</code></pre><p>Notice that <code>A₃</code> is a Julia matrix rather than a Jet operator.</p><h2 id="Operator-linear-combinations"><a class="docs-heading-anchor" href="#Operator-linear-combinations">Operator linear combinations</a><a id="Operator-linear-combinations-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-linear-combinations" title="Permalink"></a></h2><p>Operators can be built from linear combinations of operators,</p><pre><code class="language-julia">using Jets, JetPack
A₁ = JopDiagonal(rand(10))
A₂ = JopDiagonal(rand(10))
A₃ = rand(10,10)
A = 1.0*A₁ - 2.0*A₂ + 3.0*A₃                # operator linear combination
m = rand(domain(A))
A*m ≈ 1.0*(A₁*m) - 2.0*(A₂*m) + 3.0*(A₃*m)  # true</code></pre><h2 id="Block-operators,-block-spaces-and-block-vectors"><a class="docs-heading-anchor" href="#Block-operators,-block-spaces-and-block-vectors">Block operators, block spaces and block vectors</a><a id="Block-operators,-block-spaces-and-block-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Block-operators,-block-spaces-and-block-vectors" title="Permalink"></a></h2><p>Jet operators can be combined into block operators which are exactly analogous to block matrices. The domain and ranges of a block operator are of type <code>JetBSpace</code> and such that vectors in that space are block vectors of type <code>BlockArray</code>. In order to construct a block operator, we use the <code>@blockop</code> macro. For example:</p><pre><code class="language-julia">using Jets, JetPack
A = @blockop [JopDiagonal(rand(10)) for irow=1:2, icol=1:3]</code></pre><p>In the above code listing, <code>A</code> is a block operator with 2 row-blocks and 3 column-blocks. Given a block operator, we can query for the number of blocks as well as retrieve individual blocks:</p><pre><code class="language-julia">A₁₂ = getblock(A, 1, 2)
nb = nblocks(A)
nrowblocks = nblocks(A, 1)
ncolblocks = nblocks(A, 2)</code></pre><p>We can form block vectors in the domain and range of <code>A</code>. Moreover, once we have formed a block vector, we can access individual blocks. For example,</p><pre><code class="language-julia">d = rand(range(A))
m = rand(domain(A))

nblocks(d)          # return 2
nblocks(m)          # return 3

d₂ = getblock(d, 2) # this is not a copy, it is a reference to the second block of d
m₁ = getblock(m, 1)

setblock!(d, 2, rand(size(d₂)...))</code></pre><p>We can reshape Julia Array&#39;s into block arrays. For example,</p><pre><code class="language-julia">_d = rand(eltype(range(A)), size(range(A)))
d = reshape(_d, range(A))</code></pre><p>Since <code>BlockArrays</code> extend Julia&#39;s <code>AbstractArray</code> and broadcasting interfaces, most of the functionality of a Julia <code>Array</code> is also available for <code>BlockArray</code>&#39;s.</p><h2 id="Vectorized-operators"><a class="docs-heading-anchor" href="#Vectorized-operators">Vectorized operators</a><a id="Vectorized-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorized-operators" title="Permalink"></a></h2><p>There are libraries that assume that the vectors in the model and data space are backed by one dimensional arrays.  To help with this, Jets provides a <code>vec</code> method that returns an operator with one dimensional arrays backing the domain and range.  As an example, we show how to compose Jets with the <code>lsqr</code> method in the IterativeSolvers package.</p><pre><code class="language-julia">using Jets, JetPackTransforms, IterativeSolvers
A = JopDct(Float64, 128, 64)
d = rand(range(A))
m = reshape(lsqr(vec(A), vec(d)), range(A))
A*m ≈ d # true</code></pre><p>Note that for the case that the domain and range are already backed by one dimensional arrays, <code>vec</code> is a no-op. Further, note that a block array is a one dimensional array.  </p><h2 id="Creating-a-new-Jet-(Developers)"><a class="docs-heading-anchor" href="#Creating-a-new-Jet-(Developers)">Creating a new Jet (Developers)</a><a id="Creating-a-new-Jet-(Developers)-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-new-Jet-(Developers)" title="Permalink"></a></h2><p>To build a new jet, provide the function that maps from the domain to the range, its linearization and a default state. We will show three examples: 1) linear operator, 2) self-adjoint linear operator, 3) nonlinear operator.</p><h3 id="Linear-operator"><a class="docs-heading-anchor" href="#Linear-operator">Linear operator</a><a id="Linear-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-operator" title="Permalink"></a></h3><pre><code class="language-julia">using Jets
MyLinearJet_df!(d, m; A, kwargs...) = mul!(d,A,m)
MyLinearJet_df′!(m, d; A, kwargs...) = mul!(m,A&#39;,d)
function MyLinearJet()
    JopLn(dom = JetSpace(Float64,2), rng = JetSpace(Float64,2), 
        df! = MyLinearJet_df!, df′! = MyLinearJet_df′!, s=(A=rand(2,2),))
end</code></pre><h3 id="Self-adjoint-linear-operator"><a class="docs-heading-anchor" href="#Self-adjoint-linear-operator">Self-adjoint linear operator</a><a id="Self-adjoint-linear-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Self-adjoint-linear-operator" title="Permalink"></a></h3><pre><code class="language-julia">using Jets
MySelfAdjointJet_df!(d, m; A, kwargs...) = mul!(d,A,m)
function MySelfAdjointJet()
    B = rand(2,2)
    JopLn(dom = JetSpace(Float64,2), rng = JetSpace(Float64,2), 
        df! = MySelfAdjointJet_df!, s = (A=B&#39;*B,))
end</code></pre><h3 id="Nonlinear-operator"><a class="docs-heading-anchor" href="#Nonlinear-operator">Nonlinear operator</a><a id="Nonlinear-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-operator" title="Permalink"></a></h3><pre><code class="language-julia">using Jets
MyNonLinearJet_f!(d, m; a, kwargs...) = d .= x.^a
MyNonLinearJet_df!(d, m; mₒ, a, kwargs...) = d .= a * mₒ.^(a-1) .* m
function MyNonLinearJet()
    JopNl(dom = JetSpace(Float64,2), rng = JetSpace(Float64,2), 
        f! = MyNonLinearJet_f!, df! = MyNonLinearJet_df!, s = (a=2.0,))
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 30 May 2023 14:58">Tuesday 30 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Jets.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Jets.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Jets</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChevronETC/Jets.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Jop,AbstractArray}" href="#Base.:*-Tuple{Jop,AbstractArray}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">:*(F, m)</code></pre><p>Constructs <code>F*m</code> where F is a Jets linear (e.g. <code>JopLn</code>) or nonlinear (<code>JopNl</code>) operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L379-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{Union{JopAdjoint, JopLn},Union{JopAdjoint, JopLn}}" href="#Base.:+-Tuple{Union{JopAdjoint, JopLn},Union{JopAdjoint, JopLn}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">:+(A₂, A₁)</code></pre><p>Construct and return the linear combination of the two <code>Jets</code> operators <code>A₁::Jop</code> and <code>A₂::Jop</code>. Note that <code>A₁</code> and <code>A₂</code> must have consistent (same size and type) domains and ranges.</p><p><strong>Example</strong></p><pre><code class="language-none">A = 1.0*A₁ - 2.0*A₂ + 3.0*A₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L659-L669">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{Union{JopAdjoint, JopLn},Union{JopAdjoint, JopLn}}" href="#Base.:--Tuple{Union{JopAdjoint, JopLn},Union{JopAdjoint, JopLn}}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">:-(A₂, A₁)</code></pre><p>Construct and return the linear combination of the two <code>Jets</code> operators <code>A₁::Jop</code> and <code>A₂::Jop</code>. Note that <code>A₁</code> and <code>A₂</code> must have consistent (same size and type) domains and ranges.</p><p><strong>Example</strong></p><pre><code class="language-none">A = 1.0*A₁ - 2.0*A₂ + 3.0*A₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L675-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∘-Tuple{Union{JopAdjoint, JopLn},Union{JopAdjoint, JopLn}}" href="#Base.:∘-Tuple{Union{JopAdjoint, JopLn},Union{JopAdjoint, JopLn}}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">:∘(A₂, A₁)</code></pre><p>Construct the composition of the two <code>Jets</code> operators.  Note that when applying the composition operator, operators are applied in order from right to left: first <code>A₁</code> and then <code>A₂</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Jets
dg!(d,m;mₒ) = @. d = 2*m
A₁ = JopLn(Jet(;dom=JetSpace(Float64,2), rng=JetSpace(Float64,2), df! = dg!))
A₂ = JopLn(Jet(;dom=JetSpace(Float64,2), rng=JetSpace(Float64,2), df! = dg!))
C = A₂ ∘ A₁
m = rand(domain(C))
d = C * m</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L533-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.adjoint-Tuple{JopLn}" href="#Base.adjoint-Tuple{JopLn}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adjoint(A::Union{JopLn, JopAdjoint})</code></pre><p>Return the adjoint of the of A.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L362-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{T}, Tuple{Type{T},Jop}} where T&lt;:Array" href="#Base.convert-Union{Tuple{T}, Tuple{Type{T},Jop}} where T&lt;:Array"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(Array, A::JopLn)</code></pre><p>Convert a linear Jets operator into its equivalent matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L1105-L1109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Tuple{Jet}" href="#Base.eltype-Tuple{Jet}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eltype(A::Union{Jet,Jop,JopAdjoint})</code></pre><p>Return the element type of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L236-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Union{Tuple{JetAbstractSpace{T,N} where N}, Tuple{T}} where T" href="#Base.eltype-Union{Tuple{JetAbstractSpace{T,N} where N}, Tuple{T}} where T"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eltype(R)</code></pre><p>Determine the element type of the space <code>R::JetAbstractSpace</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iszero-Union{Tuple{Jet{D,R,typeof(Jets.JopZeroBlock_df!),DF,DF′,U,M,S} where S&lt;:NamedTuple where M&lt;:AbstractArray where U&lt;:Function where DF′&lt;:Function where DF&lt;:Function}, Tuple{R}, Tuple{D}} where R&lt;:JetAbstractSpace where D&lt;:JetAbstractSpace" href="#Base.iszero-Union{Tuple{Jet{D,R,typeof(Jets.JopZeroBlock_df!),DF,DF′,U,M,S} where S&lt;:NamedTuple where M&lt;:AbstractArray where U&lt;:Function where DF′&lt;:Function where DF&lt;:Function}, Tuple{R}, Tuple{D}} where R&lt;:JetAbstractSpace where D&lt;:JetAbstractSpace"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">iszero(A::Union{Jet, Jop})</code></pre><p>Return true if <code>A</code> was constructed via <code>JopZeroBlock</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L916-L920">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{JetAbstractSpace}" href="#Base.length-Tuple{JetAbstractSpace}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(R)</code></pre><p>Return the dimension the space <code>R::JetAbstractSpace</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ones" href="#Base.ones"><code>Base.ones</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ones(R)</code></pre><p>Construct an array of the type and size defined by <code>R::JetAbstractSpace{T}</code> and filled with <code>one(T)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rand(R)</code></pre><p>Construct an array of the type and size defined by the <code>R::JetAbstractSpace</code>, and filled with random values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.range-Tuple{Jet}" href="#Base.range-Tuple{Jet}"><code>Base.range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = range(A)</code></pre><p>Return <code>R::JetAbstractSpace</code>, which is the range of <code>A::Union{Jet, Jop, AbstractMatrix}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L229-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reshape-Tuple{AbstractArray,JetAbstractSpace}" href="#Base.reshape-Tuple{AbstractArray,JetAbstractSpace}"><code>Base.reshape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reshape(x, R)</code></pre><p>Returns an array that is consistent with the shape of the space <code>R::JetAbstractSpace</code>, and shares memory with <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{JetAbstractSpace,Any}" href="#Base.size-Tuple{JetAbstractSpace,Any}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(R[,i])</code></pre><p>Return the shape of the array associated to the Jet space R::JetAbstractSpace. If <code>i</code> is specifid, then returns the length along the ith array dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{Union{Jet, Jop},Any}" href="#Base.size-Tuple{Union{Jet, Jop},Any}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(A[, i])</code></pre><p>Return the size of the range and domain of <code>A::Union{Jet,Jop}</code>.  With no arguments, return <code>(length(range(A)), length(domain(A)))</code>.  With <code>i</code> specified, return <code>length(range(A))</code> for <code>i = 1</code> and return <code>length(domain(A))</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L332-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros" href="#Base.zeros"><code>Base.zeros</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">zeros(R)</code></pre><p>Construct an array of the type and size defined by <code>R::JetAbstractSpace{T}</code> and filled with <code>zero(T)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.JopZeroBlock-Tuple{JetAbstractSpace,JetAbstractSpace}" href="#Jets.JopZeroBlock-Tuple{JetAbstractSpace,JetAbstractSpace}"><code>Jets.JopZeroBlock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopZeroBlock(dom, rng)</code></pre><p>Construct a Jets operator that is equivalent to a matrix of zeros, and that maps from <code>dom::JetAbstractSpace</code> to <code>rng::JetAbstractSpace</code>.  This can be useful when forming block operators that contain zero blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L907-L912">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.domain-Tuple{Jet}" href="#Jets.domain-Tuple{Jet}"><code>Jets.domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = domain(A)</code></pre><p>Return <code>R::JetAbstractSpace</code>, which is the domain of <code>A::Union{Jet, Jop, AbstractMatrix}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L222-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.dot_product_test-Tuple{JopLn,AbstractArray,AbstractArray}" href="#Jets.dot_product_test-Tuple{JopLn,AbstractArray,AbstractArray}"><code>Jets.dot_product_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lhs,rhs = dot_product_test(A, m, d; mmask, dmask)</code></pre><p>Compute and return the left and right hand sides of the <em>dot product test</em>:</p><p><span>$&lt;d,Am&gt; pprox &lt;A^Hd,m&gt;$</span></p><p>Here <span>$A^H$</span> is the conjugate transpose or adjoint of <span>$A$</span>, and <span>$&lt;x, y&gt;$</span> denotes the inner product of vectors <span>$x$</span> and <span>$y$</span>. The left and right hand sides of the dot product test are expected to be equivalent close to machine precision for operator <span>$A$</span>. If the equality does not hold this can indicate a problem with the implementation of the operator <span>$A$</span>.</p><p>This function provides the optional named arguments <code>mmask</code> and <code>dmask</code> which are vectors in the domain and range of <code>A</code> that are applied via elementwise multiplication to mask the vectors <code>m</code> and <code>d</code> before applying of the operator, as shown below. Here we use <code>∘</code> to represent the Hadamard product (elementwise multiplication) of two vectors.</p><p><span>$&lt;dmask ∘ d, A (mmask ∘ m)&gt; ≈ &lt;Aᵀ (dmask ∘ d), mmask ∘ m&gt;$</span></p><p>You can test the relative accuracy of the operator with this relation for the left hand side <code>lhs</code> and right hand side <code>rhs</code> returned by this function: <span>$|lhs - rhs| / |lhs + rhs| &lt; ϵ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L1123-L1144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.getblock-Union{Tuple{R}, Tuple{D}, Tuple{Jet{D,R,typeof(Jets.JetBlock_f!),DF,DF′,U,M,S} where S&lt;:NamedTuple where M&lt;:AbstractArray where U&lt;:Function where DF′&lt;:Function where DF&lt;:Function,Any,Any}} where R where D" href="#Jets.getblock-Union{Tuple{R}, Tuple{D}, Tuple{Jet{D,R,typeof(Jets.JetBlock_f!),DF,DF′,U,M,S} where S&lt;:NamedTuple where M&lt;:AbstractArray where U&lt;:Function where DF′&lt;:Function where DF&lt;:Function,Any,Any}} where R where D"><code>Jets.getblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getblock(A, i, j)</code></pre><p>Return the block of the Jets block operator <code>A</code> that corresponds to row block <code>i</code> and column block <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L1051-L1056">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.indices-Tuple{JetBSpace,Integer}" href="#Jets.indices-Tuple{JetBSpace,Integer}"><code>Jets.indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">indices(R, iblock)</code></pre><p>Return the linear indices associated with block <code>iblock</code> in the <code>Jets</code> block space <code>R::JetBSpace</code>.</p><p><strong>Example</strong></p><p>Consider a block operator with 2 row-blocks and 3 column-blocks.  We can use <code>indices</code> to determine the elements of the vector that are associatd with the first block of its domain:</p><pre><code class="language-none">using Pkg
pkg&quot;add JetPack&quot;
using Jets, JetPack
A = @blockop [JopDiagonal(rand(10)) for irow=1:2, icol=1:3]
indices(domain(A), 1) # returns indices 1:10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L738-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.isblockop-Tuple{Jop{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:(Jet{var&quot;#s21&quot;,var&quot;#s20&quot;,typeof(Jets.JetBlock_f!),DF,DF′,U,M,S} where S&lt;:NamedTuple where M&lt;:AbstractArray where U&lt;:Function where DF′&lt;:Function where DF&lt;:Function where var&quot;#s20&quot;&lt;:JetAbstractSpace where var&quot;#s21&quot;&lt;:JetAbstractSpace)}" href="#Jets.isblockop-Tuple{Jop{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:(Jet{var&quot;#s21&quot;,var&quot;#s20&quot;,typeof(Jets.JetBlock_f!),DF,DF′,U,M,S} where S&lt;:NamedTuple where M&lt;:AbstractArray where U&lt;:Function where DF′&lt;:Function where DF&lt;:Function where var&quot;#s20&quot;&lt;:JetAbstractSpace where var&quot;#s21&quot;&lt;:JetAbstractSpace)}"><code>Jets.isblockop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isblockop(A)</code></pre><p>Return true if <code>A</code> is a Jets block operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L1064-L1068">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.jacobian!-Tuple{Jet,AbstractArray}" href="#Jets.jacobian!-Tuple{Jet,AbstractArray}"><code>Jets.jacobian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jacobian!(F, m₀)</code></pre><p>Return the jacobian of <code>F::Union{Jet, Jop, AbstractMatrix}</code> at the linearization point <code>m₀</code>. The jacobian shares the underlying <code>Jet</code> with <code>F</code>. This means that if the jacobian may mutate <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L342-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.jacobian-Tuple{Union{Jet, Jop},AbstractArray}" href="#Jets.jacobian-Tuple{Union{Jet, Jop},AbstractArray}"><code>Jets.jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jacobian(F, m₀)</code></pre><p>Return the jacobian of <code>F::Union{Jet, Jop, AbstractMatrix}</code> at the point <code>m₀</code>. The linearization constructs a new underlying <code>Jet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L353-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.jet-Tuple{Jop}" href="#Jets.jet-Tuple{Jop}"><code>Jets.jet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jet(A)</code></pre><p>Return the <code>Jet</code> associated with <code>A::Union{Jop, JopAdjoint}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L288-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.linearity_test-Tuple{Union{JopAdjoint, JopLn}}" href="#Jets.linearity_test-Tuple{Union{JopAdjoint, JopLn}}"><code>Jets.linearity_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lhs,rhs = linearity_test(A::Jop)</code></pre><p>test the the linear Jet operator <code>A</code> satisfies the following test for linearity: <span>$A(m_1+m_2)=Am_1 + A_m2$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L1203-L1208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.linearization_test-Tuple{JopNl,AbstractArray}" href="#Jets.linearization_test-Tuple{JopNl,AbstractArray}"><code>Jets.linearization_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">μobs, μexp = linearization_test(F, mₒ; μ)</code></pre><p>Thest that the jacobian, <span>$J$</span>, of <span>$F$</span> satisfies the Taylor expansion:</p><p><span>$F(m) = F(m_o) + F&#39;(m_o)δm + O(δm^2)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L1162-L1168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.nblocks-Tuple{JetBSpace}" href="#Jets.nblocks-Tuple{JetBSpace}"><code>Jets.nblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nblocks(R)</code></pre><p>Return the number of blocks in the <code>Jets</code> block space <code>R::JetBSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L777-L781">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.nblocks-Tuple{Jet}" href="#Jets.nblocks-Tuple{Jet}"><code>Jets.nblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nblocks(A[, i])</code></pre><p>Return the number of blocks in the range and domain of the <code>Jets</code> block operator <code>A::Union{Jet, Jop}</code>. With <code>i</code> specified, return <code>nblocks(range(jet))</code> for <code>i = 1</code> and return <code>nblocks(domain(jet))</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L1040-L1045">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.perfstat-Union{Tuple{T}, Tuple{T}, Tuple{F}, Tuple{R}, Tuple{D}} where T&lt;:(Jet{D,R,F,DF,DF′,U,M,S} where S&lt;:NamedTuple where M&lt;:AbstractArray where U&lt;:Function where DF′&lt;:Function where DF&lt;:Function) where F&lt;:Function where R where D" href="#Jets.perfstat-Union{Tuple{T}, Tuple{T}, Tuple{F}, Tuple{R}, Tuple{D}} where T&lt;:(Jet{D,R,F,DF,DF′,U,M,S} where S&lt;:NamedTuple where M&lt;:AbstractArray where U&lt;:Function where DF′&lt;:Function where DF&lt;:Function) where F&lt;:Function where R where D"><code>Jets.perfstat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perfstat(A)</code></pre><p>Return a <code>Dictionary</code> with performance information for A::Union{Jet,Jop,JopAdjoint}. the <code>perfstat(jet::Jet)</code> method that can be implemented by the author of an operator to track performance metrics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L259-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.point!-Tuple{Jet,AbstractArray}" href="#Jets.point!-Tuple{Jet,AbstractArray}"><code>Jets.point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">point!(F, mₒ)</code></pre><p>Update the linearization point (model vector) for <code>F::Union{Jet, JopLn, JopAdjoint}</code> to model vector <code>mₒ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.point-Tuple{Jet}" href="#Jets.point-Tuple{Jet}"><code>Jets.point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">point(F)</code></pre><p>Return the linearization point (model vector) <code>mₒ</code> associated with <code>F::Union{Jet, JopLn, JopAdjoint}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L268-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.shape-Tuple{Union{Jet, Jop}}" href="#Jets.shape-Tuple{Union{Jet, Jop}}"><code>Jets.shape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shape(A[, i])</code></pre><p>Return the shape of the range and domain of <code>A::Union{Jet, Jop, AbstractMatrix}</code>. With no arguments, return <code>(size(range(A)), size(domain(A)))</code>.  With <code>i</code> specified, return <code>size(range(A))</code> for <code>i = 1</code> and return <code>size(domain(A))</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L320-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.space-Tuple{JetBSpace,Integer}" href="#Jets.space-Tuple{JetBSpace,Integer}"><code>Jets.space</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">space(R, iblock)</code></pre><p>Return the <code>Jets</code> sub-space associated with block <code>iblock</code> in the <code>Jets</code> block space <code>R::JetBSpace</code>.</p><p><strong>Example</strong></p><p>Consider a block operator with 2 row-blocks and 3 column-blocks.  We can use <code>space</code> to determine the sub-space associated with the first block of its domain:</p><pre><code class="language-none">using Pkg
Pkg.add(&quot;Jets&quot;, &quot;JetPack&quot;)
using Jets, JetPack
A = @blockop [JopDiagonal(rand(10)) for irow=1:2, icol=1:3]
space(domain(A), 1) # JetSpace(Float64,10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L758-L774">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.state!-Tuple{Any,Any}" href="#Jets.state!-Tuple{Any,Any}"><code>Jets.state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">state!(A::Union{Jet,Jop,JopAdjoint}, s)</code></pre><p>Updates and merges the state of the <code>A</code> with <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.state-Tuple{Jet}" href="#Jets.state-Tuple{Jet}"><code>Jets.state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">state(A::Union{Jet,Jop,JopAdjoint}[, key])</code></pre><p>If <code>key::Symbol</code> is specified, then return the state corresponding to <code>key</code>. Otherwise, return the state of A as a <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L243-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{AbstractArray,JopNl,AbstractArray}" href="#LinearAlgebra.mul!-Tuple{AbstractArray,JopNl,AbstractArray}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mul!(d, F, m)</code></pre><p>In place version of <code>d=F*m</code> where F is a Jets linear (e.g. <code>JopLn</code>) or nonlinear (<code>JopNl</code>) operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L370-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Random.randperm-Tuple{JetAbstractSpace,Int64}" href="#Random.randperm-Tuple{JetAbstractSpace,Int64}"><code>Random.randperm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randperm(R)</code></pre><p>Construct a list of random linear indices over the dimensions of <code>R::JetAbstractSpace</code>.  The list is useful for selecting a random subset of a multi-dimensional image.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Jets
R = JetSpace(Float64, 10, 2)
x = rand(R)
y = x[randperm(R)[1:10]] # get 10 elements at random from x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L100-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Array" href="#Core.Array"><code>Core.Array</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Array(R)</code></pre><p>Construct an uninitialized array of the type and size defined by <code>R::JetsAbstractSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.Jet-Tuple{}" href="#Jets.Jet-Tuple{}"><code>Jets.Jet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jet(;dom, rng, f!, df!, df′!, upstate!, s)</code></pre><p>Return a <code>Jet</code> with domain <code>dom::JetAbstractSpace</code>, range <code>rng::JetSAbstractpace</code>, with forward mapping  <code>f!::Function</code>, linearized forward mapping <code>df!::Function</code>, linearized adjoint mapping <code>df′!::Function</code>, Jacobian state modification function <code>upstate!::Function</code>, and state <code>s::NamedTuple</code>.</p><p>A jet describes a function <code>f!</code> and its linearization (forward <code>df!, and adjoint</code>df′!``) about a point.</p><p>If one of <code>f!</code> or <code>df!</code> is specified, and <code>df′!</code> is not, then we assume that <code>f!=df!=df′!</code>. This means that the operator is linear and self-adjoint.</p><p>If <code>f!</code> and <code>df!</code> are sepecified, bug <code>df′!</code> is not, then we assume that <code>df′!=df!</code>.  This means that the operator is nonlinear and self-adjoint.</p><p><strong>Example</strong></p><p>Consider a nonlinear mapping with a self-adjoint linearization <span>$f(x)=x^2$</span></p><pre><code class="language-julia">using Jets
g!(m) = m.^2
dg!(δm; mₒ) = @. 2*mₒ*δm
jet = Jet(;dom=JetSpace(Float64,2), rng=JetSpace(Float64,2), f! = g!, df! = dg!)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L129-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.JetSSpace-Union{Tuple{F}, Tuple{N}, Tuple{T}, Tuple{Type{T},Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}},F}} where F where N where T" href="#Jets.JetSSpace-Union{Tuple{F}, Tuple{N}, Tuple{T}, Tuple{Type{T},Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}},F}} where F where N where T"><code>Jets.JetSSpace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JetSSpace(_T, n, M, map::F)</code></pre><p>Construct and return a symmetric space <code>JetSSpace</code>.</p><p><strong>parameters</strong></p><ul><li><code>_T</code> is the type, usually <code>Complex{Float32}</code> or <code>Complex{Float64}</code>.</li><li><code>n</code> is a tuple that defines the dimensionality of the space.</li><li><code>M</code> is a tuple that defines which dimensions are symmetric. Note that currently only a single symmetric dimension is supported by the API.</li><li><code>F</code> is a function that maps indices for the symmetric dimension, described below.</li></ul><p>An example requiring a <code>JetSSpace</code> is the Fourier transform: the Fourier transform of a real vector is in a complex space with Hermittian symmetry. Only the positive frequencies are needed, and the spectrum at negative frequencies is the Hermittian conjugate of the spectrum at the corresponding positive frequencies: <code>S(-f) = conj(S(f)</code>. For this example the map <code>F</code> is a function that returns the multi-dimensional index of <code>f</code> when given the multi-dimensional index of <code>-f</code>.</p><p>See also: <code>JopFft</code> in the <code>JetPackTransforms</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L399-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.JetSpace-Union{Tuple{N}, Tuple{T}, Tuple{Type{T},Vararg{Int64,N}}} where N where T" href="#Jets.JetSpace-Union{Tuple{N}, Tuple{T}, Tuple{Type{T},Vararg{Int64,N}}} where N where T"><code>Jets.JetSpace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JetSpace(T, n)</code></pre><p>Construct and return a JetSpace of type <code>T</code> and size <code>n</code></p><p><strong>Examples</strong></p><p>Create a 100 dimension space with array elelment type Float64 and array size (100,)</p><pre><code class="language-none">R1 = JetSpace(Float64, 100)</code></pre><p>Create a 100 dimension space with array element type Float32 and array size (5, 20)</p><pre><code class="language-none">R2 = JetSpace(Float32, 5, 20)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L44-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.JopLn-Tuple{}" href="#Jets.JopLn-Tuple{}"><code>Jets.JopLn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopLn(; kwargs ...)</code></pre><p>Construct a <code>JopLn</code> with <code>Jet</code> constructed from keyword arguments <code>kwargs</code>. This is equivalent to <code>JopLn(Jet(;kwargs...))</code>.  Please see <code>Jet</code> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L199-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jets.JopNl-Tuple{}" href="#Jets.JopNl-Tuple{}"><code>Jets.JopNl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopNl(; kwargs ...)</code></pre><p>Construct a <code>JopNl</code> with <code>Jet</code> constructed from keyword arguments <code>kwargs</code>. This is equivalent to <code>JopNl(Jet(;kwargs...))</code>.  Please see <code>Jet</code> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/Jets.jl/blob/381e1e94b81142546d6550ffa4f259dc706546d4/src/Jets.jl#L185-L191">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Jets</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 September 2020 04:04">Wednesday 23 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
